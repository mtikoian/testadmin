/* A PEEK INTO THE 4TH DIMENSION WITH SQL SERVER

MAIN QUERY - SQL Saturday 480 Nashville - 01/16/2015 */

/*
											########          ######   #######  ##       
											   ##            ##    ## ##     ## ##       
											   ##            ##       ##     ## ##       
											   ##    #######  ######  ##     ## ##       
											   ##                  ## ##  ## ## ##       
											   ##            ##    ## ##    ##  ##       
											   ##             ######   ##### ## ######## 

 ########     ###    ######## ########  ######        ###    ##    ## ########     ######## #### ##     ## ######## 
##     ##   ## ##      ##    ##       ##    ##      ## ##   ###   ## ##     ##       ##     ##  ###   ### ##       
##     ##  ##   ##     ##    ##       ##           ##   ##  ####  ## ##     ##       ##     ##  #### #### ##       
##     ## ##     ##    ##    ######    ######     ##     ## ## ## ## ##     ##       ##     ##  ## ### ## ######   
##     ## #########    ##    ##             ##    ######### ##  #### ##     ##       ##     ##  ##     ## ##       
##     ## ##     ##    ##    ##       ##    ##    ##     ## ##   ### ##     ##       ##     ##  ##     ## ##       
########  ##     ##    ##    ########  ######     ##     ## ##    ## ########        ##    #### ##     ## ########

*/

/*
                             O
                            (_)
                          _ )_( _
                        /`_) H (_`\
                      .' (  { }  ) '.
                   [_.'   _,...,_   '._]
                    _/ /` '-'='-' `\ \_
                    |   .:"`````":.   |
                    |__//_________\\__|
                     | .-----------. |
                     | |  .-"""-.  | |
                     | | /    /  \ | |
                     | ||-   <   -|| |
                     | | \    \  / | |
                     | |[`'-...-'`]| |
                     | | ;-.___.-; | |
                     | | |  |||  | | |
                     | | |  |||  | | |
                     | | |  |||  | | |
                     | | |  |||  | | |
                     | | |  |||  | | |
                     | | | _|||_ | | |
                     | | | >===< | | |
                     | | | |___| | | |
                     | | |  |||  | | |
                     | | |  ;-;  | | |
                     | | | (   ) | | |
                     | | |  '-'  | | |
                     | | '-------' | |
                    _| '-----------' |_
                   [= === === ==== == =]
                   [__--__--___--__--__]
                  /__-___-___-___-___-__\
                 `"""""""""""""""""""""""`


*/





--THE BEGINNING - Where are we at NOW

SELECT GETDATE()


--WHERE WILL WE BE TOMORROW
--This is an example of an Implicit conversion of INT to DateTime

SELECT GETDATE() + 1 AS Tomorrow

--WHAT WAS 5 DAYS AGO

SELECT GETDATE() - 5 AS Five_Days_Ago

--A YEAR AGO

SELECT GETDATE() - 365 AS Year_Ago

--A BETTER WAY TO AVOID IMPLICIT CONVERSIONS

Select Convert(date,dateadd(day,-365,GetDate()))


--HOW OLD AM I

SELECT DATEDIFF(YEAR,'05/21/1969',GETDATE())


--What is the Year part only of today

SELECT YEAR(GETDATE())


--What is the year 6 years from now

SELECT DATEPART(YY,GETDATE()) + 6

--Another way to do it

SELECT YEAR(GETDATE()) + 6

--What is the actual Date 6 Years from now BEST PRACTICE

SELECT DATEADD(year, 6,GETDATE())

-- How old will I be then THIS WILL BECOME USEFUL LATER

SELECT DATEDIFF(yyyy,'05/21/1969',  DATEADD(year, 6,GETDATE()))


--These have all been basic T-SQL Funcitons to return a value generated by SQL Server. Notice there is no table data and thus no FROM statement.


--Here are some more system generated dates and times and and an introduciton to data types conversion for the results. 
--We can use CAST or CONVERT to do the same explicit conversion.
--In this case we are using 


--Introducing UTC
-- https://msdn.microsoft.com/en-us/library/bb630289.aspx


SELECT  GETDATE() AS TODAY,
        GETUTCDATE() AS TODAY_UTC ,
        CURRENT_TIMESTAMP AS TODAY_TS,
        CAST(GETDATE() AS DATETIMEOFFSET) AS TODAY_DTO ,
		CAST(GETDATE() AS DATETIMEOFFSET)  AS TODAY_DTO ,
		CONVERT(DATETIME,GETDATE()) AS TODAY_CONVERT,
		CONVERT(TIME,GETDATE()) AS TIME_CONVERT, -- TIME 
		DATEDIFF(hh,GETDATE(), GETUTCDATE()) AS TZ_Hour_Diff, -- Time dofference from Central to UTC in HOURS
        CAST(GETDATE() AS DATETIME2) AS TODAY_DT2;


--Date Parts
--How can we get only part of a date
--Lets say we only needed to know the day

SELECT  DAY(GETDATE()) ,
        MONTH(GETDATE()) ,
        YEAR(GETDATE())



--Now we only want to see the Day Name

SELECT DATENAME(WEEKDAY,GETDATE())
--WHICH IS THE SAME AS
SELECT DATENAME(dw,GETDATE())


--So far we have been converting dates ( today ) to other date data types.
--Now let's convert dates to other date types, specifically intigers. This will also become useful when we get to data

--Date and Time Conversion to INT


SELECT CAST(GETDATE() AS INT) AS TODAY_INT,
CAST(CAST('01/01/1900' AS DATETIME) AS BIGINT) AS  DEFAULT_Date_Int,
CAST( -53690 AS DATETIME) AS Earliest_Date,
CAST(CAST('01/01/1753' AS DATETIME) AS INT) AS  EARLIEST_DATE_INT,
CAST( 2958463 AS DATETIME) AS LAST_DATE,
CAST(CAST('12/31/9999' AS DATETIME) AS INT) AS  LAST_DATE_INT

--Notice the ranges of the datetime date type. datetime2 will go back to 0001.

--Now let's convert or cast an integer back to a date

 SELECT CAST( -53691 AS DATETIME2)

 
--RANDONM DATES - This will be useful later

--This is one way to generate random dates
SELECT  
        CAST(CAST( + ( 42383 ) * RAND() AS INT) AS DATETIME) AS RANDOM_DATE_BETWEEN_1900_and_01_16_2016,
		GETDATE() AS TODAY,
		CAST(GETDATE() AS INT) AS TODAY_INT


--BUT THIS IS A BETTER WAY, WHICH WE WILL SEE WHY SHORTLY

SELECT CAST(ABS(checksum(NewId()) % 42380) AS DATETIME)


--Now Lets Create a Simple Stored Procedure
-- GET AGE STORED PROCEDURE

IF OBJECT_ID('GET_Time_Birthday','P') IS NOT NULL
  DROP PROCEDURE GET_Time_Birthday; 
  GO
CREATE PROC GET_Time_Birthday @BDay DATETIME
AS
    SELECT  DATEDIFF(YEAR, @BDay, GETDATE())-1 AS AGE_YEARS,
            DATEDIFF(M, @BDay, GETDATE()) AS AGE_MONTHS ,
            DATEDIFF(D, @BDay, GETDATE()) AS AGE_DAYS,
            DATEDIFF(mi, @BDay, GETDATE()) AS AGE_MINUTES


Get_Time_Birthday '10/28/1976'


-- A QUICK LOOK AT DIVIDING TIME
-- DIVIDING MINUTES


SELECT 90 / 60 AS Integer_Result

--Integer value of 1 returned. We really need 1.5

SELECT CAST(90 / 60 AS FLOAT) NOT_YET

--Not quite there yet

SELECT CAST(90 AS FLOAT) / 60 AS BETTER

--But this gives us fractional hours 1 and a half hours. How to we get 1 hour and 30 minutes?
--We need to get the remainder. has to be two separate fields, unless you want a character string

SELECT 90/ 60 AS HOUR_INT, 90 % 60 AS MINUTES

--Combine these as a string

SELECT CAST(90/ 60 AS VARCHAR(5))  + ':' + CAST( 90 % 60 AS varchar(5))AS Hours_Minutes


/*
##      ## ##     ## ######## ##      ## 
##  ##  ## ##     ## ##       ##  ##  ## 
##  ##  ## ##     ## ##       ##  ##  ## 
##  ##  ## ######### ######   ##  ##  ## 
##  ##  ## ##     ## ##       ##  ##  ## 
##  ##  ## ##     ## ##       ##  ##  ## 
 ###  ###  ##     ## ########  ###  ###  
 */


 --WE DID ALL THAT WORK WITHOUT SEEING ONE SINGLE PIECE OF REAL DATA IN A REAL TABLE
--Lets take a break and go to the:

/*
##     ##  #######  ##     ## #### ########  ######  
###   ### ##     ## ##     ##  ##  ##       ##    ## 
#### #### ##     ## ##     ##  ##  ##       ##       
## ### ## ##     ## ##     ##  ##  ######    ######  
##     ## ##     ##  ##   ##   ##  ##             ## 
##     ## ##     ##   ## ##    ##  ##       ##    ## 
##     ##  #######     ###    #### ########  ######  
*/

--REAL DATA FINALLY
http://www.hometheaterinfo.com/dvdlist.htm


SELECT [DVD_Title]
      ,[Studio]
      ,[Released]
      ,[Status]
      ,[Sound]
      ,[Versions]
      ,[Price]
      ,[Rating]
      ,[Year]
      ,[Genre]
      ,[Aspect]
      ,[UPC]
      ,[DVD_ReleaseDate]
	  ,DateKey
      ,[ID]
      ,[Timestamp]
      ,[RunnningTime]
      ,[Draw]
  FROM [Movies].[dbo].[DVD]
  
  --Notice the DateKey is NULL. We will update it shortly

  --And now for Mr HANKS

  SELECT TOP 1000 [DVD_Title]
      ,[Studio]
      ,[Released]
      ,[Status]
      ,[Sound]
      ,[Versions]
      ,[Price]
      ,[Rating]
      ,[Year]
      ,[Genre]
      ,[Aspect]
      ,[UPC]
      ,[DVD_ReleaseDate]
      ,DVD.[ID]
      ,[Timestamp]
      ,[RunnningTime]
      ,[Draw]
	  ,Actors_Names.Actor
  FROM [Movies].[dbo].[DVD] LEFT OUTER JOIN Actors_dvd ON DVD.ID = Actors_DVD.DVDList_id
  LEFT OUTER JOIN Actors_Names ON Actors_DVD.Actor_id = dbo.Actors_Names.Actor_id
   WHERE Actors_Names.Actor LIKE '%Hanks, T%'

   --And a Date Range

     SELECT TOP 1000 [DVD_Title]
      ,[Studio]
      ,[Price]
      ,[Rating]
      ,[Year]
      ,[Genre] 
      ,[DVD_ReleaseDate] 
      ,[RunnningTime]
      ,[Draw]
	  ,Actors_Names.Actor
  FROM [Movies].[dbo].[DVD] LEFT OUTER JOIN Actors_dvd ON DVD.ID = Actors_DVD.DVDList_id
  LEFT OUTER JOIN Actors_Names ON Actors_DVD.Actor_id = dbo.Actors_Names.Actor_id
   WHERE Actors_Names.Actor LIKE '%Hanks, T%' AND DVD_ReleaseDate BETWEEN '01/01/1976' AND '01/01/2015'
   ORDER BY [YEAR]

 
-- Just for fun let's find all DVDs that have "TIME" OR "DATE" In the title that are older than 01/16/2016

SELECT TOP 3000
        dbo.DVD.DVD_Title ,
        DVD_ReleaseDate
FROM    dbo.DVD
WHERE   DVD_ReleaseDate <= '01/16/2016'
        AND DVD_Title LIKE '% Time %'
        OR DVD_Title LIKE '% Date %'
ORDER BY DVD_ReleaseDate DESC;


--How about all DVDs that came out on Wednesday

SELECT TOP 3000
        dbo.DVD.DVD_Title ,
        DVD_ReleaseDate,
		DATENAME(WeekDay,DVD_ReleaseDate) AS Release_Day
FROM    dbo.DVD
WHERE   DATENAME(WeekDay,DVD_ReleaseDate) = 'Saturday'
ORDER BY DVD_ReleaseDate DESC;


--JUST 2010 Releases
--TIME TO INTRODUCE SOME METRICS AS WELL
SET STATISTICS IO ON
SET STATISTICS TIME ON
GO

SELECT TOP 2000
        dbo.DVD.DVD_Title ,
        DVD_ReleaseDate,
		DATENAME(WeekDay,DVD_ReleaseDate)
FROM    dbo.DVD
WHERE  YEAR(DVD_ReleaseDate) = '2010'
ORDER BY DVD_Title ASC

--HOW ABOUT WITH A STORED YEAR VALUE INSTEAD OF A FUNCITON
--THIS IS A QUCIK EXAMPLE OF SARGABILITY
https://www.simple-talk.com/sql/performance/identifying-and-solving-index-scan-problems/
--You dont want to use a funciton on the left side of the predicate
--The following is much better as it is a stored value


SELECT TOP 2000
        dbo.DVD.DVD_Title ,
        DVD_ReleaseDate,
		DATENAME(WeekDay,DVD_ReleaseDate)
FROM    dbo.DVD
WHERE  YEAR_RELEASED = '2010'
ORDER BY DVD_Title ASC;


--This brings us to the DateTable and how it can be useful

-- Building  A Date Dimension TABLE
-- borrowed from http://michaelmorley.name/how-to/create-date-dimension-table-in-sql-server
/*
########  ########  ######   #### ##    ## 
##     ## ##       ##    ##   ##  ###   ## 
##     ## ##       ##         ##  ####  ## 
########  ######   ##   ####  ##  ## ## ## 
##     ## ##       ##    ##   ##  ##  #### 
##     ## ##       ##    ##   ##  ##   ### 
########  ########  ######   #### ##    ## 
*/
CREATE TABLE Numbers_First_Tem (Number INT);

INSERT INTO Numbers_First_Tem
VALUES (0)	,(1)	,(2)	,(3)	,(4)	,(5)	,(6)	,(7)	,(8)	,(9);
GO

/* Create Second numbers table for key generation */
CREATE TABLE HIGH_Numbers (HIGH BIGINT);

INSERT INTO HIGH_Numbers (HIGH)
SELECT  ( tth.Number * 10000 + th.Number * 1000
          + hun.Number * 100 + ten.Number * 10 + one.Number ) AS HIGH
FROM    Numbers_First_Tem tth ,
        Numbers_First_Tem th ,
        Numbers_First_Tem hun ,
        Numbers_First_Tem ten ,
        Numbers_First_Tem one
ORDER BY HIGH

IF OBJECT_ID('DateTable', 'U') IS NOT NULL
  DROP TABLE dbo.DateTable; 
/* Create DateTable */
CREATE TABLE [dbo].[DateTable] (
	[DateKey] [int] NOT NULL
	,[Date] [datetime] NOT NULL
	,[Day] [char](10) NULL
	,[DayOfWeek] [smallint] NULL
	,[DayOfMonth] [smallint] NULL
	,[DayOfYear] [smallint] NULL
	,[WeekOfYear] [smallint] NULL
	,[Month] [char](10) NULL
	,[MonthOfYear] [smallint] NULL
	,[QuarterOfYear] [smallint] NULL
	,[Year] [int] NULL
	);
GO

/* Create Date Key and Date Fields */
INSERT INTO [DateTable] (
	DateKey
	,DATE
	)
SELECT HIGH
	,DATEADD(day, High, '1900-01-01') AS DATE
FROM dbo.HIGH_Numbers
WHERE DATEADD(day, HIGH, '1900-01-01') BETWEEN '1900-01-01'
		AND '2030-12-31'
ORDER BY dbo.HIGH_Numbers.HIGH
GO

/* Update all other fields with appropriate data. */
UPDATE [DateTable]
SET Day = DATENAME(DW, DATE)
	,DayOfWeek = DATEPART(WEEKDAY, DATE)
	,DayOfMonth = DAY(DATE)
	,DayOfYear = DATEPART(DY, DATE)
	,WeekOfYear = DATEPART(WK, DATE)
	,Month = DATENAME(MONTH, DATE)
	,MonthOfYear = MONTH(DATE)
	,QuarterOfYear = DATEPART(Q, DATE)
	,Year = YEAR(DATE);
GO

/****** Object:  Index [idx_DateKey]    Script Date: 1/14/2016 10:53:07 PM ******/
CREATE CLUSTERED INDEX [idx_DateKey] ON [dbo].[DateTable]
(
	[DateKey] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO


CREATE NONCLUSTERED INDEX [idx_Dates_All] ON [dbo].[DateTable]
(
	[Date] ASC
)
INCLUDE ( 	[Day],
	[DayOfWeek],
	[DayOfMonth],
	[DayOfYear],
	[WeekOfYear],
	[Month],
	[MonthOfYear],
	[QuarterOfYear],
	[Year]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO


/* Drop Temp Tables */
DROP TABLE dbo.Numbers_First_Tem;

DROP TABLE dbo.HIGH_Numbers;



/*
######## ##    ## ########  
##       ###   ## ##     ## 
##       ####  ## ##     ## 
######   ## ## ## ##     ## 
##       ##  #### ##     ## 
##       ##   ### ##     ## 
######## ##    ## ########  
 */




--NOW We want to update the datekeys

UPDATE DVD SET DateKey = CAST(DVD_ReleaseDate AS INT)

--UPDATE DVD SET DateKey = NULL




-- Saturday Query Re-written with DateTable

SELECT TOP 3000
        dbo.DVD.DVD_Title ,
        DVD_ReleaseDate,
		DATENAME(WeekDay,DVD_ReleaseDate)
FROM    dbo.DVD
INNER JOIN dbo.DateTable ON DVD.Datekey = dbo.DateTable.DateKey
WHERE  dbo.DateTable.Day = 'Saturday'
ORDER BY dbo.DVD.DVD_Title  DESC;


-- Get Runtime in Hours and Minutes For Kevin Bacon Movies Between 1976 and 2015

 SELECT [DVD_Title]
      ,[Rating]
      ,[Year]
      ,[Genre] 
      ,[RunnningTime] AS RUNNING_TIMES_MINUTES
	  ,CAST([RunnningTime] AS FLOAT) / 60 AS Running_Time_Hours
	  ,Actors_Names.Actor
  FROM [Movies].[dbo].[DVD] LEFT OUTER JOIN Actors_dvd ON DVD.ID = Actors_DVD.DVDList_id
  LEFT OUTER JOIN Actors_Names ON Actors_DVD.Actor_id = dbo.Actors_Names.Actor_id
   WHERE Actors_NAmes.Actor_id = '3398' AND DVD_ReleaseDate BETWEEN '01/01/1976' AND '01/01/2015'
   ORDER BY [YEAR]


--What about only movies that came out on the last day of a month OR first day of month.


    SELECT  [DVD_Title] ,
            DVD_ReleaseDate,
			EOMONTH(DVD_ReleaseDate) EOM_RD,
			EOMONTH(DVD_ReleaseDate,10) EOM_RD_One_Year_Offset
    FROM    [Movies].[dbo].[DVD]
    WHERE   DVD_ReleaseDate = EOMONTH(DVD_ReleaseDate)
            OR DVD_ReleaseDate = DATEADD(MONTH,
                                         DATEDIFF(MONTH, 0, DVD_ReleaseDate),
                                         0)
    ORDER BY DVD_Title



	--Formatting Dates

	
DECLARE @d DATETIME = '10/01/2016';
SELECT FORMAT ( @d, 'd', 'en-US' ) AS 'US English Result'
      ,FORMAT ( @d, 'd', 'en-gb' ) AS 'Great Britain English Result',
	  		FORMAT ( @d, 'yyyy.dd.MM', 'de-de' ) AS 'German Result',
		FORMAT ( @d, 'yyyy.dd.MM', 'de-de' ) AS 'German Result'

--OR


	  SELECT 
   GETDATE() AS UnconvertedDateTime,
   CAST(GETDATE() AS nvarchar(30)) AS UsingCast,
   CONVERT(nvarchar(30), GETDATE(), 103) AS English,  
   CONVERT(nvarchar(30), GETDATE(), 104) AS German,
   CONVERT(nvarchar(30), GETDATE(), 3) AS English,  
   CONVERT(nvarchar(30), GETDATE(), 4) AS German 
	   ;
GO




	--ISDATE

	SELECT ISDATE('2016\12\31')
	SELECT ISDATE('2016/12/31')
	SELECT ISDATE('20161231')
	SELECT ISDATE(1)



--THE CASE STATEMENT WITH DATES WORK on YEAR UNCLEAN DATA

SELECT TOP 3000
        dbo.DVD.DVD_Title ,
		DVD.DVD_ReleaseDate,
		YEAR_Released,
		[YEAR],
		CASE WHEN ISDATE([YEAR]) = 1 THEN 1 ELSE 0 END AS OK
		--DATEDIFF(yy,YEAR(dbo.DVD.DVD_ReleaseDate),CAST([year] AS DATE)) ELSE [Year] END AS Whatever
 
FROM    dbo.DVD
WHERE   DVD_ReleaseDate <= '01/16/2016'
        AND DVD_Title LIKE '% Time %'
        OR DVD_Title LIKE '% Date %'
ORDER BY DVD_ReleaseDate DESC;

--Lets TRY TO clean it up with CASE

SELECT TOP 3000
        dbo.DVD.DVD_Title ,
		DVD.DVD_ReleaseDate,
		YEAR_Released,
		[YEAR] AS Year_MADE,
		CASE WHEN ISDATE([YEAR]) <> 1 THEN DATEDIFF(yy,'1900',DVD.DVD_ReleaseDate)   ELSE DATEDIFF(yy,[Year],DVD.DVD_ReleaseDate) END AS OK
		--DATEDIFF(yy,YEAR(dbo.DVD.DVD_ReleaseDate),CAST([year] AS DATE)) ELSE [Year] END AS Whatever
 
FROM    dbo.DVD
WHERE   DVD_ReleaseDate <= '01/16/2016'
        AND DVD_Title LIKE '% Time %'
        OR DVD_Title LIKE '% Date %'
ORDER BY DVD_ReleaseDate DESC;

	/*
   ###    ##    ## ########              
  ## ##   ###   ## ##     ##             
 ##   ##  ####  ## ##     ##             
##     ## ## ## ## ##     ##             
######### ##  #### ##     ##             
##     ## ##   ### ##     ## ### ### ### 
##     ## ##    ## ########  ### ### ### 
*/

--FINALLY We are getting to the end of the SQL Function and conversion samples


--Let's update the actors birthdays with randon dates (Except for Hanks and Bacon)

UPDATE Actors_Names SET dbo.Actors_Names.BirthDate = CAST(CAST(+ ( 42383 ) * RAND() AS INT) AS DATETIME) WHERE Actor_id NOT IN ('1846','3398')


--Let's Check to see if it worked


/****** Script for SelectTopNRows command from SSMS  ******/
SELECT TOP 1000 [Actor_id]
      ,[Actor]
      ,[Birthdate]
  FROM [Movies].[dbo].[Actors_Names] WHERE Actor LIKE '%Hanks%'

 --Something went wrong
 --LETS TRY NEWID() Which guarentees a new value 

 UPDATE Actors_Names SET dbo.Actors_Names.BirthDate = CAST(ABS(checksum(NewId()) % 42380) AS DATETIME) WHERE Actor_id NOT IN ('1846','3398')

 --Let's Test Again

 SELECT TOP 1000 [Actor_id]
      ,[Actor]
      ,[Birthdate]
  FROM [Movies].[dbo].[Actors_Names] WHERE Actor LIKE '%Hanks%'


--UPDATE WITH CURSORS - DONT DO IT - This sample script ran for almost 20 minutes and update statement hundreds of thousandss of times. Cursors are good for small result sets
DECLARE @draw Int --Movie Draw

DECLARE db_cursor CURSOR FOR  
SELECT ID
FROM Movies..DVD

OPEN db_cursor   
FETCH NEXT FROM db_cursor INTO @draw   
WHILE @@FETCH_STATUS = 0   
BEGIN   
       UPDATE DVD SET Draw = CAST(1000000 + (300000000)*RAND() AS INT)
	   WHERE ID = @Draw   

       FETCH NEXT FROM db_cursor INTO @draw   
 
END   
CLOSE db_cursor   
DEALLOCATE db_cursor 


/*
######## ##     ## ########    ######## #### ##    ##    ###    ##       
   ##    ##     ## ##          ##        ##  ###   ##   ## ##   ##       
   ##    ##     ## ##          ##        ##  ####  ##  ##   ##  ##       
   ##    ######### ######      ######    ##  ## ## ## ##     ## ##       
   ##    ##     ## ##          ##        ##  ##  #### ######### ##       
   ##    ##     ## ##          ##        ##  ##   ### ##     ## ##       
   ##    ##     ## ########    ##       #### ##    ## ##     ## ######## 

   */



   --WE want one stored procedure that does year and quarter




 ALTER PROC GET_Movies_By_Date
 @DateIn DateTime,
 @By CHAR(1)
 AS

 IF @By = 'Q'
 BEGIN

SELECT 
        dbo.DVD.DVD_Title ,
		DVD.DVD_ReleaseDate,
		[YEAR] AS Year_MADE
 
FROM    dbo.DVD
WHERE   DVD_ReleaseDate BETWEEN  DATEADD(qq, DATEDIFF(qq, 0, @DateIn), 0) AND DATEADD (dd, -1, DATEADD(qq, DATEDIFF(qq, 0, @DateIn) +1, 0))
        AND (DVD_Title LIKE '% Time %'
        OR DVD_Title LIKE '% Date %')
ORDER BY DVD_ReleaseDate DESC

END

ELSE

IF @By = 'Y'
BEGIN

SELECT 
        dbo.DVD.DVD_Title ,
		DVD.DVD_ReleaseDate,
		[YEAR] AS Year_MADE
 
FROM    dbo.DVD
WHERE   DVD_ReleaseDate BETWEEN DATEADD(yy, DATEDIFF(yy,0,@DateIn), 0) AND   DATEADD(yy, DATEDIFF(yy,0,@DateIn) + 1, -1) 
        AND (DVD_Title LIKE '% Time %'
        OR DVD_Title LIKE '% Date %')
ORDER BY DVD_ReleaseDate DESC

END

GO


GET_Movies_By_Date @Datein= '05/21/2014', @By='Y'
 


-- Timezone and Daylight saving
--
DECLARE @DTO_3 AS DATETIMEOFFSET(3);
DECLARE @DTO_4 AS DATETIMEOFFSET(4);
DECLARE @DTO_PDX_DST_On AS DATETIMEOFFSET(3);
DECLARE @DTO_PDX_DST_Off AS DATETIMEOFFSET(3);

SET @DTO_3 = GETUTCDATE();
SET @DTO_4 = SYSDATETIMEOFFSET();
SELECT @DTO_3, @DTO_4;
SELECT @DTO_3, SWITCHOFFSET(@DTO_3, '+11:00');

SET @DTO_PDX_DST_On = '2014-11-02 00:00:00 -07:00';
SET @DTO_PDX_DST_Off = '2014-11-02 09:00:00 -08:00';


SELECT DATEDIFF(HOUR, @DTO_PDX_DST_On , @DTO_PDX_DST_Off);
SELECT DATEDIFF(HOUR, @DTO_PDX_DST_On, '2014-11-02 00:00:00'); -- when no timzone is specified, it'd be considered as UTC.


DECLARE @DT2_3 AS DATETIME;

SET @DT2_3 = '2006-12-30 23:19:29.999'
SELECT @DT2_3
GO

-- Tip #10
-- DATETIME2 - Size dependent on accuracy level.

DECLARE @DT2_3 AS DATETIME2(3);

SET @DT2_3 = '2006-12-30 23:19:29.12375'
SELECT @DT2_3

SELECT DATALENGTH(@DT2_3) Size, @DT2_3 StoredValue
GO

-- Out of Range
DECLARE @DateString VARCHAR(30) = '01 JAN 1500 05:03:29';


SELECT 
	CAST(@DateString AS SMALLDATETIME)	AS SmallDateTimeConversion,
	CAST(@DateString AS DATETIME)		AS DateTimeConversion;
GO


-- This will fail: 
-- Msg 242, Level 16, State 3, Line 4
-- The conversion of a varchar data type to a smalldatetime data type resulted in an out-of-range value.


DECLARE @DateString VARCHAR(30) = '01 JAN 1500 05:03:29';
SELECT 
	TRY_CAST(@DateString AS SMALLDATETIME)	AS SmallDateTimeConversion,
	TRY_CAST(@DateString AS DATETIME)		AS DateTimeConversion;

GO

-- This will return NULL if it's not possible to convert the value.

DECLARE @DateString VARCHAR(30) = '01 JAN 1500 05:03:29 +10:00';

SELECT
	CAST(@DateString AS DATETIMEOFFSET)	AS DateTimeOffsetCast,
	CONVERT(DATETIME2, @DateString)		AS DateTime2Conversion;
-- This will return timezone default to 0
